{"ast":null,"code":"import _objectSpread from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport { useProxiedModel } from \"../proxiedModel.mjs\";\nimport { getCurrentInstance, getUid, propsFactory } from \"../../util/index.mjs\";\nimport { computed, inject, onBeforeUnmount, provide, ref } from 'vue';\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from \"./openStrategies.mjs\";\nimport { classicSelectStrategy, independentSelectStrategy, independentSingleSelectStrategy, leafSelectStrategy, leafSingleSelectStrategy } from \"./selectStrategies.mjs\"; // Types\nexport var VNestedSymbol = Symbol[\"for\"]('vuetify:nested');\nexport var emptyNested = {\n  id: ref(),\n  root: {\n    register: function register() {\n      return null;\n    },\n    unregister: function unregister() {\n      return null;\n    },\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: function open() {\n      return null;\n    },\n    openOnSelect: function openOnSelect() {\n      return null;\n    },\n    select: function select() {\n      return null;\n    },\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([])\n  }\n};\nexport var makeNestedProps = propsFactory({\n  selectStrategy: [String, Function],\n  openStrategy: [String, Object],\n  opened: Array,\n  selected: Array,\n  mandatory: Boolean\n}, 'nested');\nexport var useNested = function useNested(props) {\n  var isUnmounted = false;\n  var children = ref(new Map());\n  var parents = ref(new Map());\n  var opened = useProxiedModel(props, 'opened', props.opened, function (v) {\n    return new Set(v);\n  }, function (v) {\n    return _toConsumableArray(v.values());\n  });\n  var selectStrategy = computed(function () {\n    if (_typeof(props.selectStrategy) === 'object') return props.selectStrategy;\n    switch (props.selectStrategy) {\n      case 'single-leaf':\n        return leafSingleSelectStrategy(props.mandatory);\n      case 'leaf':\n        return leafSelectStrategy(props.mandatory);\n      case 'independent':\n        return independentSelectStrategy(props.mandatory);\n      case 'single-independent':\n        return independentSingleSelectStrategy(props.mandatory);\n      case 'classic':\n      default:\n        return classicSelectStrategy(props.mandatory);\n    }\n  });\n  var openStrategy = computed(function () {\n    if (_typeof(props.openStrategy) === 'object') return props.openStrategy;\n    switch (props.openStrategy) {\n      case 'list':\n        return listOpenStrategy;\n      case 'single':\n        return singleOpenStrategy;\n      case 'multiple':\n      default:\n        return multipleOpenStrategy;\n    }\n  });\n  var selected = useProxiedModel(props, 'selected', props.selected, function (v) {\n    return selectStrategy.value[\"in\"](v, children.value, parents.value);\n  }, function (v) {\n    return selectStrategy.value.out(v, children.value, parents.value);\n  });\n  onBeforeUnmount(function () {\n    isUnmounted = true;\n  });\n  function getPath(id) {\n    var path = [];\n    var parent = id;\n    while (parent != null) {\n      path.unshift(parent);\n      parent = parents.value.get(parent);\n    }\n    return path;\n  }\n  var vm = getCurrentInstance('nested');\n  var nested = {\n    id: ref(),\n    root: {\n      opened: opened,\n      selected: selected,\n      selectedValues: computed(function () {\n        var arr = [];\n        var _iterator = _createForOfIteratorHelper(selected.value.entries()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            if (value === 'on') arr.push(key);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        return arr;\n      }),\n      register: function register(id, parentId, isGroup) {\n        parentId && id !== parentId && parents.value.set(id, parentId);\n        isGroup && children.value.set(id, []);\n        if (parentId != null) {\n          children.value.set(parentId, [].concat(_toConsumableArray(children.value.get(parentId) || []), [id]));\n        }\n      },\n      unregister: function unregister(id) {\n        if (isUnmounted) return;\n        children.value[\"delete\"](id);\n        var parent = parents.value.get(id);\n        if (parent) {\n          var _children$value$get;\n          var list = (_children$value$get = children.value.get(parent)) !== null && _children$value$get !== void 0 ? _children$value$get : [];\n          children.value.set(parent, list.filter(function (child) {\n            return child !== id;\n          }));\n        }\n        parents.value[\"delete\"](id);\n        opened.value[\"delete\"](id);\n      },\n      open: function open(id, value, event) {\n        vm.emit('click:open', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newOpened = openStrategy.value.open({\n          id: id,\n          value: value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      openOnSelect: function openOnSelect(id, value, event) {\n        var newOpened = openStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      select: function select(id, value, event) {\n        vm.emit('click:select', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newSelected = selectStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newSelected && (selected.value = newSelected);\n        nested.root.openOnSelect(id, value, event);\n      },\n      children: children,\n      parents: parents\n    }\n  };\n  provide(VNestedSymbol, nested);\n  return nested.root;\n};\nexport var useNestedItem = function useNestedItem(id, isGroup) {\n  var parent = inject(VNestedSymbol, emptyNested);\n  var computedId = computed(function () {\n    var _id$value;\n    return (_id$value = id.value) !== null && _id$value !== void 0 ? _id$value : Symbol(getUid());\n  });\n  var item = _objectSpread(_objectSpread({}, parent), {}, {\n    id: computedId,\n    open: function open(_open, e) {\n      return parent.root.open(computedId.value, _open, e);\n    },\n    openOnSelect: function openOnSelect(open, e) {\n      return parent.root.openOnSelect(computedId.value, open, e);\n    },\n    isOpen: computed(function () {\n      return parent.root.opened.value.has(computedId.value);\n    }),\n    parent: computed(function () {\n      return parent.root.parents.value.get(computedId.value);\n    }),\n    select: function select(selected, e) {\n      return parent.root.select(computedId.value, selected, e);\n    },\n    isSelected: computed(function () {\n      return parent.root.selected.value.get(computedId.value) === 'on';\n    }),\n    isIndeterminate: computed(function () {\n      return parent.root.selected.value.get(computedId.value) === 'indeterminate';\n    }),\n    isLeaf: computed(function () {\n      return !parent.root.children.value.get(computedId.value);\n    }),\n    isGroupActivator: parent.isGroupActivator\n  });\n  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);\n  onBeforeUnmount(function () {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value);\n  });\n  isGroup && provide(VNestedSymbol, item);\n  return item;\n};\nexport var useNestedGroupActivator = function useNestedGroupActivator() {\n  var parent = inject(VNestedSymbol, emptyNested);\n  provide(VNestedSymbol, _objectSpread(_objectSpread({}, parent), {}, {\n    isGroupActivator: true\n  }));\n};","map":{"version":3,"mappings":"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","names":["useProxiedModel","getCurrentInstance","getUid","propsFactory","computed","inject","onBeforeUnmount","provide","ref","listOpenStrategy","multipleOpenStrategy","singleOpenStrategy","classicSelectStrategy","independentSelectStrategy","independentSingleSelectStrategy","leafSelectStrategy","leafSingleSelectStrategy","VNestedSymbol","Symbol","emptyNested","id","root","register","unregister","parents","Map","children","open","openOnSelect","select","opened","Set","selected","selectedValues","makeNestedProps","selectStrategy","String","Function","openStrategy","Object","Array","mandatory","Boolean","useNested","props","isUnmounted","v","values","value","out","getPath","path","parent","unshift","get","vm","nested","arr","entries","key","push","parentId","isGroup","set","list","filter","child","event","emit","newOpened","newSelected","useNestedItem","computedId","item","e","isOpen","has","isSelected","isIndeterminate","isLeaf","isGroupActivator","useNestedGroupActivator"],"sources":["../../../src/composables/nested/nested.ts"],"sourcesContent":["import { useProxiedModel } from '@/composables/proxiedModel'\nimport { getCurrentInstance, getUid, propsFactory } from '@/util'\nimport { computed, inject, onBeforeUnmount, provide, ref } from 'vue'\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from './openStrategies'\nimport {\n  classicSelectStrategy,\n  independentSelectStrategy,\n  independentSingleSelectStrategy,\n  leafSelectStrategy,\n  leafSingleSelectStrategy,\n} from './selectStrategies'\n\n// Types\nimport type { InjectionKey, PropType, Ref } from 'vue'\nimport type { SelectStrategyFn } from './selectStrategies'\nimport type { OpenStrategy } from './openStrategies'\n\nexport type SelectStrategy = 'single-leaf' | 'leaf' | 'independent' | 'single-independent' | 'classic' | SelectStrategyFn\nexport type OpenStrategyProp = 'single' | 'multiple' | 'list' | OpenStrategy\n\nexport interface NestedProps {\n  selectStrategy: SelectStrategy | undefined\n  openStrategy: OpenStrategyProp | undefined\n  selected: unknown[] | undefined\n  opened: unknown[] | undefined\n  mandatory: boolean\n  'onUpdate:selected': ((val: unknown[]) => void) | undefined\n  'onUpdate:opened': ((val: unknown[]) => void) | undefined\n}\n\ntype NestedProvide = {\n  id: Ref<unknown>\n  isGroupActivator?: boolean\n  root: {\n    children: Ref<Map<unknown, unknown[]>>\n    parents: Ref<Map<unknown, unknown>>\n    opened: Ref<Set<unknown>>\n    selected: Ref<Map<unknown, 'on' | 'off' | 'indeterminate'>>\n    selectedValues: Ref<unknown[]>\n    register: (id: unknown, parentId: unknown, isGroup?: boolean) => void\n    unregister: (id: unknown) => void\n    open: (id: unknown, value: boolean, event?: Event) => void\n    select: (id: unknown, value: boolean, event?: Event) => void\n    openOnSelect: (id: unknown, value: boolean, event?: Event) => void\n  }\n}\n\nexport const VNestedSymbol: InjectionKey<NestedProvide> = Symbol.for('vuetify:nested')\n\nexport const emptyNested: NestedProvide = {\n  id: ref(),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    openOnSelect: () => null,\n    select: () => null,\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n  },\n}\n\nexport const makeNestedProps = propsFactory({\n  selectStrategy: [String, Function] as PropType<SelectStrategy>,\n  openStrategy: [String, Object] as PropType<OpenStrategyProp>,\n  opened: Array as PropType<unknown[]>,\n  selected: Array as PropType<unknown[]>,\n  mandatory: Boolean,\n}, 'nested')\n\nexport const useNested = (props: NestedProps) => {\n  let isUnmounted = false\n  const children = ref(new Map<unknown, unknown[]>())\n  const parents = ref(new Map<unknown, unknown>())\n\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()])\n\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy\n\n    switch (props.selectStrategy) {\n      case 'single-leaf': return leafSingleSelectStrategy(props.mandatory)\n      case 'leaf': return leafSelectStrategy(props.mandatory)\n      case 'independent': return independentSelectStrategy(props.mandatory)\n      case 'single-independent': return independentSingleSelectStrategy(props.mandatory)\n      case 'classic':\n      default: return classicSelectStrategy(props.mandatory)\n    }\n  })\n\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'object') return props.openStrategy\n\n    switch (props.openStrategy) {\n      case 'list': return listOpenStrategy\n      case 'single': return singleOpenStrategy\n      case 'multiple':\n      default: return multipleOpenStrategy\n    }\n  })\n\n  const selected = useProxiedModel(\n    props,\n    'selected',\n    props.selected,\n    v => selectStrategy.value.in(v, children.value, parents.value),\n    v => selectStrategy.value.out(v, children.value, parents.value),\n  )\n\n  onBeforeUnmount(() => {\n    isUnmounted = true\n  })\n\n  function getPath (id: unknown) {\n    const path: unknown[] = []\n    let parent: unknown = id\n\n    while (parent != null) {\n      path.unshift(parent)\n      parent = parents.value.get(parent)\n    }\n\n    return path\n  }\n\n  const vm = getCurrentInstance('nested')\n\n  const nested: NestedProvide = {\n    id: ref(),\n    root: {\n      opened,\n      selected,\n      selectedValues: computed(() => {\n        const arr = []\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key)\n        }\n\n        return arr\n      }),\n      register: (id, parentId, isGroup) => {\n        parentId && id !== parentId && parents.value.set(id, parentId)\n\n        isGroup && children.value.set(id, [])\n\n        if (parentId != null) {\n          children.value.set(parentId, [...children.value.get(parentId) || [], id])\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return\n\n        children.value.delete(id)\n        const parent = parents.value.get(id)\n        if (parent) {\n          const list = children.value.get(parent) ?? []\n          children.value.set(parent, list.filter(child => child !== id))\n        }\n        parents.value.delete(id)\n        opened.value.delete(id)\n      },\n      open: (id, value, event) => {\n        vm.emit('click:open', { id, value, path: getPath(id), event })\n\n        const newOpened = openStrategy.value.open({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newOpened && (opened.value = newOpened)\n      },\n      openOnSelect: (id, value, event) => {\n        const newOpened = openStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newOpened && (opened.value = newOpened)\n      },\n      select: (id, value, event) => {\n        vm.emit('click:select', { id, value, path: getPath(id), event })\n\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newSelected && (selected.value = newSelected)\n\n        nested.root.openOnSelect(id, value, event)\n      },\n      children,\n      parents,\n    },\n  }\n\n  provide(VNestedSymbol, nested)\n\n  return nested.root\n}\n\nexport const useNestedItem = (id: Ref<unknown>, isGroup: boolean) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const computedId = computed(() => id.value ?? Symbol(getUid()))\n\n  const item = {\n    ...parent,\n    id: computedId,\n    open: (open: boolean, e: Event) => parent.root.open(computedId.value, open, e),\n    openOnSelect: (open: boolean, e?: Event) => parent.root.openOnSelect(computedId.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    select: (selected: boolean, e?: Event) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === 'indeterminate'),\n    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),\n    isGroupActivator: parent.isGroupActivator,\n  }\n\n  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup)\n\n  onBeforeUnmount(() => {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value)\n  })\n\n  isGroup && provide(VNestedSymbol, item)\n\n  return item\n}\n\nexport const useNestedGroupActivator = () => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  provide(VNestedSymbol, { ...parent, isGroupActivator: true })\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}