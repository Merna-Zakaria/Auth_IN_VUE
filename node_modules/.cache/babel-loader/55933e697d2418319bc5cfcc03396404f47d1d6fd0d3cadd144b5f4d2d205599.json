{"ast":null,"code":"import _slicedToArray from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { mergeProps as _mergeProps, createVNode as _createVNode, Fragment as _Fragment } from \"vue\";\n// Styles\nimport \"../VSlider/VSlider.css\";\n\n// Components\nimport { filterInputProps, makeVInputProps, VInput } from \"../VInput/VInput.mjs\";\nimport { getOffset, makeSliderProps, useSlider } from \"../VSlider/slider.mjs\";\nimport { VLabel } from \"../VLabel/index.mjs\";\nimport { VSliderThumb } from \"../VSlider/VSliderThumb.mjs\";\nimport { VSliderTrack } from \"../VSlider/VSliderTrack.mjs\"; // Composables\nimport { makeFocusProps, useFocus } from \"../../composables/focus.mjs\";\nimport { useProxiedModel } from \"../../composables/proxiedModel.mjs\"; // Utilities\nimport { computed, ref } from 'vue';\nimport { defineComponent, useRender } from \"../../util/index.mjs\"; // Types\nexport var VRangeSlider = defineComponent({\n  name: 'VRangeSlider',\n  props: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeFocusProps()), makeVInputProps()), makeSliderProps()), {}, {\n    strict: Boolean,\n    modelValue: {\n      type: Array,\n      \"default\": function _default() {\n        return [0, 0];\n      }\n    }\n  }),\n  emits: {\n    'update:focused': function updateFocused(value) {\n      return true;\n    },\n    'update:modelValue': function updateModelValue(value) {\n      return true;\n    }\n  },\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots;\n    var startThumbRef = ref();\n    var stopThumbRef = ref();\n    var inputRef = ref();\n    function getActiveThumb(e) {\n      if (!startThumbRef.value || !stopThumbRef.value) return;\n      var startOffset = getOffset(e, startThumbRef.value.$el, props.direction);\n      var stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction);\n      var a = Math.abs(startOffset);\n      var b = Math.abs(stopOffset);\n      return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;\n    }\n    var _useSlider = useSlider({\n        /* eslint-disable @typescript-eslint/no-use-before-define */\n        props: props,\n        handleSliderMouseUp: function handleSliderMouseUp(newValue) {\n          var _startThumbRef$value;\n          model.value = activeThumbRef.value === ((_startThumbRef$value = startThumbRef.value) == null ? void 0 : _startThumbRef$value.$el) ? [newValue, model.value[1]] : [model.value[0], newValue];\n        },\n        handleMouseMove: function handleMouseMove(newValue) {\n          var _startThumbRef$value3;\n          var _model$value = _slicedToArray(model.value, 2),\n            start = _model$value[0],\n            stop = _model$value[1];\n          if (!props.strict && start === stop && start !== min.value) {\n            var _stopThumbRef$value, _startThumbRef$value2, _activeThumbRef$value;\n            activeThumbRef.value = newValue > start ? (_stopThumbRef$value = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value.$el : (_startThumbRef$value2 = startThumbRef.value) == null ? void 0 : _startThumbRef$value2.$el;\n            (_activeThumbRef$value = activeThumbRef.value) == null ? void 0 : _activeThumbRef$value.focus();\n          }\n          if (activeThumbRef.value === ((_startThumbRef$value3 = startThumbRef.value) == null ? void 0 : _startThumbRef$value3.$el)) {\n            model.value = [Math.min(newValue, stop), stop];\n          } else {\n            model.value = [start, Math.max(start, newValue)];\n          }\n        },\n        getActiveThumb: getActiveThumb\n        /* eslint-enable @typescript-eslint/no-use-before-define */\n      }),\n      activeThumbRef = _useSlider.activeThumbRef,\n      hasLabels = _useSlider.hasLabels,\n      max = _useSlider.max,\n      min = _useSlider.min,\n      mousePressed = _useSlider.mousePressed,\n      onSliderMousedown = _useSlider.onSliderMousedown,\n      onSliderTouchstart = _useSlider.onSliderTouchstart,\n      position = _useSlider.position,\n      roundValue = _useSlider.roundValue,\n      trackContainerRef = _useSlider.trackContainerRef;\n    var model = useProxiedModel(props, 'modelValue', undefined, function (arr) {\n      if (!arr || !arr.length) return [0, 0];\n      return arr.map(function (value) {\n        return roundValue(value);\n      });\n    });\n    var _useFocus = useFocus(props),\n      isFocused = _useFocus.isFocused,\n      focus = _useFocus.focus,\n      blur = _useFocus.blur;\n    var trackStart = computed(function () {\n      return position(model.value[0]);\n    });\n    var trackStop = computed(function () {\n      return position(model.value[1]);\n    });\n    useRender(function () {\n      var _filterInputProps = filterInputProps(props),\n        _filterInputProps2 = _slicedToArray(_filterInputProps, 2),\n        inputProps = _filterInputProps2[0],\n        _ = _filterInputProps2[1];\n      var hasPrepend = !!(props.label || slots.label || slots.prepend);\n      return _createVNode(VInput, _mergeProps({\n        \"class\": ['v-slider', 'v-range-slider', {\n          'v-slider--has-labels': !!slots['tick-label'] || hasLabels.value,\n          'v-slider--focused': isFocused.value,\n          'v-slider--pressed': mousePressed.value,\n          'v-slider--disabled': props.disabled\n        }],\n        \"ref\": inputRef\n      }, inputProps, {\n        \"focused\": isFocused.value\n      }), _objectSpread(_objectSpread({}, slots), {}, {\n        prepend: hasPrepend ? function (slotProps) {\n          var _ref3;\n          var _slots$label, _slots$prepend;\n          return _createVNode(_Fragment, null, [((_ref3 = (_slots$label = slots.label) == null ? void 0 : _slots$label.call(slots, slotProps)) !== null && _ref3 !== void 0 ? _ref3 : props.label) ? _createVNode(VLabel, {\n            \"class\": \"v-slider__label\",\n            \"text\": props.label\n          }, null) : undefined, (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, slotProps)]);\n        } : undefined,\n        \"default\": function _default(_ref2) {\n          var _startThumbRef$value4, _stopThumbRef$value4;\n          var id = _ref2.id;\n          return _createVNode(\"div\", {\n            \"class\": \"v-slider__container\",\n            \"onMousedown\": onSliderMousedown,\n            \"onTouchstartPassive\": onSliderTouchstart\n          }, [_createVNode(\"input\", {\n            \"id\": \"\".concat(id.value, \"_start\"),\n            \"name\": props.name || id.value,\n            \"disabled\": props.disabled,\n            \"readonly\": props.readonly,\n            \"tabindex\": \"-1\",\n            \"value\": model.value[0]\n          }, null), _createVNode(\"input\", {\n            \"id\": \"\".concat(id.value, \"_stop\"),\n            \"name\": props.name || id.value,\n            \"disabled\": props.disabled,\n            \"readonly\": props.readonly,\n            \"tabindex\": \"-1\",\n            \"value\": model.value[1]\n          }, null), _createVNode(VSliderTrack, {\n            \"ref\": trackContainerRef,\n            \"start\": trackStart.value,\n            \"stop\": trackStop.value\n          }, {\n            'tick-label': slots['tick-label']\n          }), _createVNode(VSliderThumb, {\n            \"ref\": startThumbRef,\n            \"focused\": isFocused && activeThumbRef.value === ((_startThumbRef$value4 = startThumbRef.value) == null ? void 0 : _startThumbRef$value4.$el),\n            \"modelValue\": model.value[0],\n            \"onUpdate:modelValue\": function onUpdateModelValue(v) {\n              return model.value = [v, model.value[1]];\n            },\n            \"onFocus\": function onFocus(e) {\n              var _startThumbRef$value5, _stopThumbRef$value2;\n              focus();\n              activeThumbRef.value = (_startThumbRef$value5 = startThumbRef.value) == null ? void 0 : _startThumbRef$value5.$el;\n\n              // Make sure second thumb is focused if\n              // the thumbs are on top of each other\n              // and they are both at minimum value\n              // but only if focused from outside.\n              if (model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== ((_stopThumbRef$value2 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value2.$el)) {\n                var _startThumbRef$value6, _stopThumbRef$value3;\n                (_startThumbRef$value6 = startThumbRef.value) == null ? void 0 : _startThumbRef$value6.$el.blur();\n                (_stopThumbRef$value3 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value3.$el.focus();\n              }\n            },\n            \"onBlur\": function onBlur() {\n              blur();\n              activeThumbRef.value = undefined;\n            },\n            \"min\": min.value,\n            \"max\": model.value[1],\n            \"position\": trackStart.value\n          }, {\n            'thumb-label': slots['thumb-label']\n          }), _createVNode(VSliderThumb, {\n            \"ref\": stopThumbRef,\n            \"focused\": isFocused && activeThumbRef.value === ((_stopThumbRef$value4 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value4.$el),\n            \"modelValue\": model.value[1],\n            \"onUpdate:modelValue\": function onUpdateModelValue(v) {\n              return model.value = [model.value[0], v];\n            },\n            \"onFocus\": function onFocus(e) {\n              var _stopThumbRef$value5, _startThumbRef$value7;\n              focus();\n              activeThumbRef.value = (_stopThumbRef$value5 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value5.$el;\n\n              // Make sure first thumb is focused if\n              // the thumbs are on top of each other\n              // and they are both at maximum value\n              // but only if focused from outside.\n              if (model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== ((_startThumbRef$value7 = startThumbRef.value) == null ? void 0 : _startThumbRef$value7.$el)) {\n                var _stopThumbRef$value6, _startThumbRef$value8;\n                (_stopThumbRef$value6 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value6.$el.blur();\n                (_startThumbRef$value8 = startThumbRef.value) == null ? void 0 : _startThumbRef$value8.$el.focus();\n              }\n            },\n            \"onBlur\": function onBlur() {\n              blur();\n              activeThumbRef.value = undefined;\n            },\n            \"min\": model.value[0],\n            \"max\": max.value,\n            \"position\": trackStop.value\n          }, {\n            'thumb-label': slots['thumb-label']\n          })]);\n        }\n      }));\n    });\n    return {};\n  }\n});","map":{"version":3,"mappings":"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","names":["filterInputProps","makeVInputProps","VInput","getOffset","makeSliderProps","useSlider","VLabel","VSliderThumb","VSliderTrack","makeFocusProps","useFocus","useProxiedModel","computed","ref","defineComponent","useRender","VRangeSlider","name","props","strict","Boolean","modelValue","type","Array","default","emits","value","setup","slots","_ref","startThumbRef","stopThumbRef","inputRef","getActiveThumb","e","startOffset","$el","direction","stopOffset","a","Math","abs","b","handleSliderMouseUp","newValue","model","activeThumbRef","_startThumbRef$value","handleMouseMove","start","stop","min","_stopThumbRef$value","_startThumbRef$value2","_activeThumbRef$value","focus","_startThumbRef$value3","max","hasLabels","mousePressed","onSliderMousedown","onSliderTouchstart","position","roundValue","trackContainerRef","undefined","arr","length","map","isFocused","blur","trackStart","trackStop","inputProps","_","hasPrepend","label","prepend","disabled","slotProps","_slots$label","_slots$prepend","id","_ref2","readonly","_startThumbRef$value4","v","_startThumbRef$value5","relatedTarget","_stopThumbRef$value2","_startThumbRef$value6","_stopThumbRef$value3","_stopThumbRef$value4","_stopThumbRef$value5","_startThumbRef$value7","_stopThumbRef$value6","_startThumbRef$value8"],"sources":["../../../src/components/VRangeSlider/VRangeSlider.tsx"],"sourcesContent":["// Styles\nimport '../VSlider/VSlider.sass'\n\n// Components\nimport { filterInputProps, makeVInputProps, VInput } from '@/components/VInput/VInput'\nimport { getOffset, makeSliderProps, useSlider } from '@/components/VSlider/slider'\nimport { VLabel } from '@/components/VLabel'\nimport { VSliderThumb } from '@/components/VSlider/VSliderThumb'\nimport { VSliderTrack } from '@/components/VSlider/VSliderTrack'\n\n// Composables\nimport { makeFocusProps, useFocus } from '@/composables/focus'\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport { computed, ref } from 'vue'\nimport { defineComponent, useRender } from '@/util'\n\n// Types\nimport type { PropType, WritableComputedRef } from 'vue'\n\nexport const VRangeSlider = defineComponent({\n  name: 'VRangeSlider',\n\n  props: {\n    ...makeFocusProps(),\n    ...makeVInputProps(),\n    ...makeSliderProps(),\n\n    strict: Boolean,\n    modelValue: {\n      type: Array as PropType<number[]>,\n      default: () => ([0, 0]),\n    },\n  },\n\n  emits: {\n    'update:focused': (value: boolean) => true,\n    'update:modelValue': (value: [number, number]) => true,\n  },\n\n  setup (props, { slots }) {\n    const startThumbRef = ref<VSliderThumb>()\n    const stopThumbRef = ref<VSliderThumb>()\n    const inputRef = ref<VInput>()\n\n    function getActiveThumb (e: MouseEvent | TouchEvent) {\n      if (!startThumbRef.value || !stopThumbRef.value) return\n\n      const startOffset = getOffset(e, startThumbRef.value.$el, props.direction)\n      const stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction)\n\n      const a = Math.abs(startOffset)\n      const b = Math.abs(stopOffset)\n\n      return (a < b || (a === b && startOffset < 0)) ? startThumbRef.value.$el : stopThumbRef.value.$el\n    }\n\n    const {\n      activeThumbRef,\n      hasLabels,\n      max,\n      min,\n      mousePressed,\n      onSliderMousedown,\n      onSliderTouchstart,\n      position,\n      roundValue,\n      trackContainerRef,\n    } = useSlider({\n      /* eslint-disable @typescript-eslint/no-use-before-define */\n      props,\n      handleSliderMouseUp: newValue => {\n        model.value = activeThumbRef.value === startThumbRef.value?.$el ? [newValue, model.value[1]] : [model.value[0], newValue]\n      },\n      handleMouseMove: newValue => {\n        const [start, stop] = model.value\n\n        if (!props.strict && start === stop && start !== min.value) {\n          activeThumbRef.value = newValue > start ? stopThumbRef.value?.$el : startThumbRef.value?.$el\n          activeThumbRef.value?.focus()\n        }\n\n        if (activeThumbRef.value === startThumbRef.value?.$el) {\n          model.value = [Math.min(newValue, stop), stop]\n        } else {\n          model.value = [start, Math.max(start, newValue)]\n        }\n      },\n      getActiveThumb,\n      /* eslint-enable @typescript-eslint/no-use-before-define */\n    })\n\n    const model = useProxiedModel(\n      props,\n      'modelValue',\n      undefined,\n      arr => {\n        if (!arr || !arr.length) return [0, 0]\n\n        return arr.map(value => roundValue(value))\n      },\n    ) as WritableComputedRef<[number, number]> & { readonly externalValue: number[] }\n\n    const { isFocused, focus, blur } = useFocus(props)\n    const trackStart = computed(() => position(model.value[0]))\n    const trackStop = computed(() => position(model.value[1]))\n\n    useRender(() => {\n      const [inputProps, _] = filterInputProps(props)\n      const hasPrepend = !!(props.label || slots.label || slots.prepend)\n\n      return (\n        <VInput\n          class={[\n            'v-slider',\n            'v-range-slider',\n            {\n              'v-slider--has-labels': !!slots['tick-label'] || hasLabels.value,\n              'v-slider--focused': isFocused.value,\n              'v-slider--pressed': mousePressed.value,\n              'v-slider--disabled': props.disabled,\n            },\n          ]}\n          ref={ inputRef }\n          { ...inputProps }\n          focused={ isFocused.value }\n        >\n          {{\n            ...slots,\n            prepend: hasPrepend ? slotProps => (\n              <>\n                { slots.label?.(slotProps) ?? props.label\n                  ? (\n                    <VLabel\n                      class=\"v-slider__label\"\n                      text={ props.label }\n                    />\n                  ) : undefined\n                }\n\n                { slots.prepend?.(slotProps) }\n              </>\n            ) : undefined,\n            default: ({ id }) => (\n              <div\n                class=\"v-slider__container\"\n                onMousedown={ onSliderMousedown }\n                onTouchstartPassive={ onSliderTouchstart }\n              >\n                <input\n                  id={ `${id.value}_start` }\n                  name={ props.name || id.value }\n                  disabled={ props.disabled }\n                  readonly={ props.readonly }\n                  tabindex=\"-1\"\n                  value={ model.value[0] }\n                />\n\n                <input\n                  id={ `${id.value}_stop` }\n                  name={ props.name || id.value }\n                  disabled={ props.disabled }\n                  readonly={ props.readonly }\n                  tabindex=\"-1\"\n                  value={ model.value[1] }\n                />\n\n                <VSliderTrack\n                  ref={ trackContainerRef }\n                  start={ trackStart.value }\n                  stop={ trackStop.value }\n                >\n                  {{ 'tick-label': slots['tick-label'] }}\n                </VSliderTrack>\n\n                <VSliderThumb\n                  ref={ startThumbRef }\n                  focused={ isFocused && activeThumbRef.value === startThumbRef.value?.$el }\n                  modelValue={ model.value[0] }\n                  onUpdate:modelValue={ v => (model.value = [v, model.value[1]]) }\n                  onFocus={ (e: FocusEvent) => {\n                    focus()\n                    activeThumbRef.value = startThumbRef.value?.$el\n\n                    // Make sure second thumb is focused if\n                    // the thumbs are on top of each other\n                    // and they are both at minimum value\n                    // but only if focused from outside.\n                    if (\n                      model.value[0] === model.value[1] &&\n                      model.value[1] === min.value &&\n                      e.relatedTarget !== stopThumbRef.value?.$el\n                    ) {\n                      startThumbRef.value?.$el.blur()\n                      stopThumbRef.value?.$el.focus()\n                    }\n                  } }\n                  onBlur={ () => {\n                    blur()\n                    activeThumbRef.value = undefined\n                  } }\n                  min={ min.value }\n                  max={ model.value[1] }\n                  position={ trackStart.value }\n                >\n                  {{ 'thumb-label': slots['thumb-label'] }}\n                </VSliderThumb>\n\n                <VSliderThumb\n                  ref={ stopThumbRef }\n                  focused={ isFocused && activeThumbRef.value === stopThumbRef.value?.$el }\n                  modelValue={ model.value[1] }\n                  onUpdate:modelValue={ v => (model.value = [model.value[0], v]) }\n                  onFocus={ (e: FocusEvent) => {\n                    focus()\n                    activeThumbRef.value = stopThumbRef.value?.$el\n\n                    // Make sure first thumb is focused if\n                    // the thumbs are on top of each other\n                    // and they are both at maximum value\n                    // but only if focused from outside.\n                    if (\n                      model.value[0] === model.value[1] &&\n                      model.value[0] === max.value &&\n                      e.relatedTarget !== startThumbRef.value?.$el\n                    ) {\n                      stopThumbRef.value?.$el.blur()\n                      startThumbRef.value?.$el.focus()\n                    }\n                  } }\n                  onBlur={ () => {\n                    blur()\n                    activeThumbRef.value = undefined\n                  } }\n                  min={ model.value[0] }\n                  max={ max.value }\n                  position={ trackStop.value }\n                >\n                  {{ 'thumb-label': slots['thumb-label'] }}\n                </VSliderThumb>\n              </div>\n            ),\n          }}\n        </VInput>\n      )\n    })\n\n    return {}\n  },\n})\n\nexport type VRangeSlider = InstanceType<typeof VRangeSlider>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}