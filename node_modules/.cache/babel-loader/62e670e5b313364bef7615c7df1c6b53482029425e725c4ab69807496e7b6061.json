{"ast":null,"code":"import _toConsumableArray from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/merna-zakaria/projects/self-learning-projects/vue_register_project/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.parse-float.js\";\n// Utilities\nimport { convertToUnit, getScrollParents, hasScrollbar, IN_BROWSER, propsFactory } from \"../../util/index.mjs\";\nimport { effectScope, nextTick, onScopeDispose, watchEffect } from 'vue';\nimport { requestNewFrame } from \"./requestNewFrame.mjs\"; // Types\nvar scrollStrategies = {\n  none: null,\n  close: closeScrollStrategy,\n  block: blockScrollStrategy,\n  reposition: repositionScrollStrategy\n};\nexport var makeScrollStrategyProps = propsFactory({\n  scrollStrategy: {\n    type: [String, Function],\n    \"default\": 'block',\n    validator: function validator(val) {\n      return typeof val === 'function' || val in scrollStrategies;\n    }\n  }\n}, 'v-overlay-scroll-strategies');\nexport function useScrollStrategies(props, data) {\n  if (!IN_BROWSER) return;\n  var scope;\n  watchEffect( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _scope;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            (_scope = scope) == null ? void 0 : _scope.stop();\n            if (data.isActive.value && props.scrollStrategy) {\n              _context.next = 3;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 3:\n            scope = effectScope();\n            _context.next = 6;\n            return nextTick();\n          case 6:\n            scope.run(function () {\n              if (typeof props.scrollStrategy === 'function') {\n                props.scrollStrategy(data, props);\n              } else {\n                var _scrollStrategies$pro;\n                (_scrollStrategies$pro = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _scrollStrategies$pro.call(scrollStrategies, data, props);\n              }\n            });\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n  onScopeDispose(function () {\n    var _scope2;\n    (_scope2 = scope) == null ? void 0 : _scope2.stop();\n  });\n}\nfunction closeScrollStrategy(data) {\n  var _data$activatorEl$val;\n  function onScroll(e) {\n    data.isActive.value = false;\n  }\n  bindScroll((_data$activatorEl$val = data.activatorEl.value) !== null && _data$activatorEl$val !== void 0 ? _data$activatorEl$val : data.contentEl.value, onScroll);\n}\nfunction blockScrollStrategy(data, props) {\n  var _data$root$value;\n  var offsetParent = (_data$root$value = data.root.value) == null ? void 0 : _data$root$value.offsetParent;\n  var scrollElements = _toConsumableArray(new Set([].concat(_toConsumableArray(getScrollParents(data.activatorEl.value, props.contained ? offsetParent : undefined)), _toConsumableArray(getScrollParents(data.contentEl.value, props.contained ? offsetParent : undefined))))).filter(function (el) {\n    return !el.classList.contains('v-overlay-scroll-blocked');\n  });\n  var scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;\n  var scrollableParent = function (el) {\n    return hasScrollbar(el) && el;\n  }(offsetParent || document.documentElement);\n  if (scrollableParent) {\n    data.root.value.classList.add('v-overlay--scroll-blocked');\n  }\n  scrollElements.forEach(function (el, i) {\n    el.style.setProperty('--v-body-scroll-x', convertToUnit(-el.scrollLeft));\n    el.style.setProperty('--v-body-scroll-y', convertToUnit(-el.scrollTop));\n    el.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth));\n    el.classList.add('v-overlay-scroll-blocked');\n  });\n  onScopeDispose(function () {\n    scrollElements.forEach(function (el, i) {\n      var x = parseFloat(el.style.getPropertyValue('--v-body-scroll-x'));\n      var y = parseFloat(el.style.getPropertyValue('--v-body-scroll-y'));\n      el.style.removeProperty('--v-body-scroll-x');\n      el.style.removeProperty('--v-body-scroll-y');\n      el.style.removeProperty('--v-scrollbar-offset');\n      el.classList.remove('v-overlay-scroll-blocked');\n      el.scrollLeft = -x;\n      el.scrollTop = -y;\n    });\n    if (scrollableParent) {\n      data.root.value.classList.remove('v-overlay--scroll-blocked');\n    }\n  });\n}\nfunction repositionScrollStrategy(data) {\n  var _data$activatorEl$val2;\n  var slow = false;\n  var raf = -1;\n  function update(e) {\n    requestNewFrame(function () {\n      var _data$updateLocation$, _data$updateLocation;\n      var start = performance.now();\n      (_data$updateLocation$ = (_data$updateLocation = data.updateLocation).value) == null ? void 0 : _data$updateLocation$.call(_data$updateLocation, e);\n      var time = performance.now() - start;\n      slow = time / (1000 / 60) > 2;\n    });\n  }\n  bindScroll((_data$activatorEl$val2 = data.activatorEl.value) !== null && _data$activatorEl$val2 !== void 0 ? _data$activatorEl$val2 : data.contentEl.value, function (e) {\n    if (slow) {\n      // If the position calculation is slow,\n      // defer updates until scrolling is finished.\n      // Browsers usually fire one scroll event per frame so\n      // we just wait until we've got two frames without an event\n      cancelAnimationFrame(raf);\n      raf = requestAnimationFrame(function () {\n        raf = requestAnimationFrame(function () {\n          update(e);\n        });\n      });\n    } else {\n      update(e);\n    }\n  });\n}\n\n/** @private */\nfunction bindScroll(el, onScroll) {\n  var scrollElements = [document].concat(_toConsumableArray(getScrollParents(el)));\n  scrollElements.forEach(function (el) {\n    el.addEventListener('scroll', onScroll, {\n      passive: true\n    });\n  });\n  onScopeDispose(function () {\n    scrollElements.forEach(function (el) {\n      el.removeEventListener('scroll', onScroll);\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["convertToUnit","getScrollParents","hasScrollbar","IN_BROWSER","propsFactory","effectScope","nextTick","onScopeDispose","watchEffect","requestNewFrame","scrollStrategies","none","close","closeScrollStrategy","block","blockScrollStrategy","reposition","repositionScrollStrategy","makeScrollStrategyProps","scrollStrategy","type","String","Function","default","validator","val","useScrollStrategies","props","data","scope","_scope","stop","isActive","value","run","_scrollStrategies$pro","_scope2","onScroll","e","bindScroll","activatorEl","contentEl","offsetParent","root","_data$root$value","scrollElements","Set","contained","undefined","filter","el","classList","contains","scrollbarWidth","window","innerWidth","document","documentElement","offsetWidth","scrollableParent","add","forEach","i","style","setProperty","scrollLeft","scrollTop","x","parseFloat","getPropertyValue","y","removeProperty","remove","slow","raf","update","start","performance","now","updateLocation","_data$updateLocation$","time","cancelAnimationFrame","requestAnimationFrame","addEventListener","passive","removeEventListener"],"sources":["../../../src/components/VOverlay/scrollStrategies.ts"],"sourcesContent":["// Utilities\nimport { convertToUnit, getScrollParents, hasScrollbar, IN_BROWSER, propsFactory } from '@/util'\nimport { effectScope, nextTick, onScopeDispose, watchEffect } from 'vue'\nimport { requestNewFrame } from './requestNewFrame'\n\n// Types\nimport type { EffectScope, PropType, Ref } from 'vue'\n\nexport interface ScrollStrategyData {\n  root: Ref<HTMLElement | undefined>\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n  updateLocation: Ref<((e: Event) => void) | undefined>\n}\n\ntype ScrollStrategyFn = (data: ScrollStrategyData, props: StrategyProps) => void\n\nconst scrollStrategies = {\n  none: null,\n  close: closeScrollStrategy,\n  block: blockScrollStrategy,\n  reposition: repositionScrollStrategy,\n}\n\nexport interface StrategyProps {\n  scrollStrategy: keyof typeof scrollStrategies | ScrollStrategyFn\n  contained: boolean | undefined\n}\n\nexport const makeScrollStrategyProps = propsFactory({\n  scrollStrategy: {\n    type: [String, Function] as PropType<StrategyProps['scrollStrategy']>,\n    default: 'block',\n    validator: (val: any) => typeof val === 'function' || val in scrollStrategies,\n  },\n}, 'v-overlay-scroll-strategies')\n\nexport function useScrollStrategies (\n  props: StrategyProps,\n  data: ScrollStrategyData\n) {\n  if (!IN_BROWSER) return\n\n  let scope: EffectScope | undefined\n  watchEffect(async () => {\n    scope?.stop()\n\n    if (!(data.isActive.value && props.scrollStrategy)) return\n\n    scope = effectScope()\n    await nextTick()\n    scope.run(() => {\n      if (typeof props.scrollStrategy === 'function') {\n        props.scrollStrategy(data, props)\n      } else {\n        scrollStrategies[props.scrollStrategy]?.(data, props)\n      }\n    })\n  })\n\n  onScopeDispose(() => {\n    scope?.stop()\n  })\n}\n\nfunction closeScrollStrategy (data: ScrollStrategyData) {\n  function onScroll (e: Event) {\n    data.isActive.value = false\n  }\n\n  bindScroll(data.activatorEl.value ?? data.contentEl.value, onScroll)\n}\n\nfunction blockScrollStrategy (data: ScrollStrategyData, props: StrategyProps) {\n  const offsetParent = data.root.value?.offsetParent\n  const scrollElements = [...new Set([\n    ...getScrollParents(data.activatorEl.value, props.contained ? offsetParent : undefined),\n    ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : undefined),\n  ])].filter(el => !el.classList.contains('v-overlay-scroll-blocked'))\n  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth\n\n  const scrollableParent = (el => hasScrollbar(el) && el)(offsetParent || document.documentElement)\n  if (scrollableParent) {\n    data.root.value!.classList.add('v-overlay--scroll-blocked')\n  }\n\n  scrollElements.forEach((el, i) => {\n    el.style.setProperty('--v-body-scroll-x', convertToUnit(-el.scrollLeft))\n    el.style.setProperty('--v-body-scroll-y', convertToUnit(-el.scrollTop))\n    el.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth))\n    el.classList.add('v-overlay-scroll-blocked')\n  })\n\n  onScopeDispose(() => {\n    scrollElements.forEach((el, i) => {\n      const x = parseFloat(el.style.getPropertyValue('--v-body-scroll-x'))\n      const y = parseFloat(el.style.getPropertyValue('--v-body-scroll-y'))\n\n      el.style.removeProperty('--v-body-scroll-x')\n      el.style.removeProperty('--v-body-scroll-y')\n      el.style.removeProperty('--v-scrollbar-offset')\n      el.classList.remove('v-overlay-scroll-blocked')\n\n      el.scrollLeft = -x\n      el.scrollTop = -y\n    })\n    if (scrollableParent) {\n      data.root.value!.classList.remove('v-overlay--scroll-blocked')\n    }\n  })\n}\n\nfunction repositionScrollStrategy (data: ScrollStrategyData) {\n  let slow = false\n  let raf = -1\n\n  function update (e: Event) {\n    requestNewFrame(() => {\n      const start = performance.now()\n      data.updateLocation.value?.(e)\n      const time = performance.now() - start\n      slow = time / (1000 / 60) > 2\n    })\n  }\n\n  bindScroll(data.activatorEl.value ?? data.contentEl.value, e => {\n    if (slow) {\n      // If the position calculation is slow,\n      // defer updates until scrolling is finished.\n      // Browsers usually fire one scroll event per frame so\n      // we just wait until we've got two frames without an event\n      cancelAnimationFrame(raf)\n      raf = requestAnimationFrame(() => {\n        raf = requestAnimationFrame(() => {\n          update(e)\n        })\n      })\n    } else {\n      update(e)\n    }\n  })\n}\n\n/** @private */\nfunction bindScroll (el: HTMLElement | undefined, onScroll: (e: Event) => void) {\n  const scrollElements = [document, ...getScrollParents(el)]\n  scrollElements.forEach(el => {\n    el.addEventListener('scroll', onScroll, { passive: true })\n  })\n\n  onScopeDispose(() => {\n    scrollElements.forEach(el => {\n      el.removeEventListener('scroll', onScroll)\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}